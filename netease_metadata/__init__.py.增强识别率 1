"""云音乐元数据提供者 for Music Assistant UI (v1.6.1)."""

from __future__ import annotations

import os
import asyncio
from json import JSONDecodeError
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any, cast, Dict, List, Optional, Set
from datetime import datetime
from contextlib import suppress

import aiohttp.client_exceptions
import mutagen
from mutagen.id3 import ID3, APIC, TPE1, TALB, TIT2, TPE2, error
from mutagen.mp3 import MP3
from mutagen.flac import FLAC, Picture
from mashumaro import DataClassDictMixin
from mashumaro.exceptions import MissingField

from music_assistant_models.config_entries import ConfigEntry
from music_assistant_models.enums import (
    ConfigEntryType,
    ExternalID,
    ImageType,
    ProviderFeature,
)
from music_assistant_models.media_items import (
    Album,
    Artist,
    ItemMapping,
    MediaItemImage,
    MediaItemMetadata,
    Track,
    UniqueList,
)
from music_assistant_models.errors import InvalidDataError, ResourceTemporarilyUnavailable

from music_assistant.controllers.cache import use_cache
from music_assistant.helpers.compare import compare_strings
from music_assistant.helpers.throttle_retry import ThrottlerManager, throttle_with_retries
from music_assistant.helpers.json import json_loads
from music_assistant.models.metadata_provider import MetadataProvider

if TYPE_CHECKING:
    from music_assistant_models.config_entries import ConfigValueType, ProviderConfig
    from music_assistant_models.provider import ProviderManifest

    from music_assistant.mass import MusicAssistant
    from music_assistant.models import ProviderInstanceType

# ------------------------------
# 1. 常量定义（模块化）
# ------------------------------
# 支持的功能
SUPPORTED_FEATURES: Set[ProviderFeature] = {
    ProviderFeature.ARTIST_METADATA,
    ProviderFeature.ALBUM_METADATA,
    ProviderFeature.TRACK_METADATA,
}

# 配置项常量
class ConfigKeys:
    """配置项键名常量类"""
    ENABLE_ARTIST_METADATA = "enable_artist_metadata"
    ENABLE_ALBUM_METADATA = "enable_album_metadata"
    ENABLE_TRACK_METADATA = "enable_track_metadata"
    ENABLE_IMAGES = "enable_images"
    WRITE_TAGS = "write_tags_to_file"
    API_URL = "api_url"
    AUTO_TRIGGER_NO_IMAGE = "auto_trigger_no_image"

# 图片类型映射
IMG_MAPPING: Dict[str, ImageType] = {
    "artist_picUrl": ImageType.THUMB,
    "album_picUrl": ImageType.THUMB,
    "track_picUrl": ImageType.THUMB,
}

# 艺术家名称清理分隔符
ARTIST_NAME_SEPARATORS = ['/', '\\', '|', '，', '；', ';', '+']

# 缓存时长（7天）
CACHE_TTL = 86400 * 7

# ------------------------------
# 2. 数据模型定义
# ------------------------------
@dataclass
class CloudMusicArtist(DataClassDictMixin):
    """云音乐艺术家数据模型"""
    id: int
    name: str
    picUrl: Optional[str] = None
    genre: Optional[str] = None
    briefDesc: Optional[str] = None
    desc: Optional[str] = None
    musicBrainzId: Optional[str] = None

@dataclass
class CloudMusicAlbum(DataClassDictMixin):
    """云音乐专辑数据模型"""
    id: int
    name: str
    picUrl: Optional[str] = None
    publishTime: Optional[int] = None
    genre: Optional[str] = None
    description: Optional[str] = None
    musicBrainzId: Optional[str] = None

@dataclass
class CloudMusicTrack(DataClassDictMixin):
    """云音乐歌曲数据模型"""
    id: int
    name: str
    ar: List[Dict[str, Any]] = field(default_factory=list)
    al: Dict[str, Any] = field(default_factory=dict)
    lyric: Optional[str] = None
    genre: Optional[str] = None
    description: Optional[str] = None

# ------------------------------
# 3. 工具函数（抽离公共逻辑）
# ------------------------------
def clean_artist_name(artist_name: Optional[str]) -> str:
    """清理艺术家名称"""
    if not artist_name:
        return ""
    
    cleaned_name = artist_name.strip()
    
    # 按分隔符切割
    for sep in ARTIST_NAME_SEPARATORS:
        if sep in cleaned_name:
            cleaned_name = cleaned_name.split(sep)[0].strip()
            break
    
    # 清理多余空格
    cleaned_name = ' '.join(cleaned_name.split())
    
    return cleaned_name

def parse_timestamp(timestamp_ms: Optional[int]) -> Optional[int]:
    """解析时间戳为年份"""
    if not timestamp_ms:
        return None
    
    try:
        timestamp_s = timestamp_ms // 1000
        return datetime.fromtimestamp(timestamp_s).year
    except (ValueError, TypeError):
        return None

# ------------------------------
# 4. 核心Provider类（日志增强版）
# ------------------------------
class CloudMusicMetadataProvider(MetadataProvider):
    """云音乐元数据提供者 (v1.6.1) - 日志增强版"""
    
    # 使用官方推荐的ThrottlerManager
    throttler = ThrottlerManager(rate_limit=10, period=1)
    
    # 配置项
    api_url: str
    write_tags: bool
    auto_trigger_no_image: bool
    enable_artist_metadata: bool
    enable_album_metadata: bool
    enable_track_metadata: bool
    enable_images: bool

    async def handle_async_init(self) -> None:
        """异步初始化（日志增强）"""
        self.cache = self.mass.cache
        
        # 读取配置项（增加默认值和类型安全）
        self.api_url = self.config.get_value(ConfigKeys.API_URL, "").rstrip("/")
        self.write_tags = self.config.get_value(ConfigKeys.WRITE_TAGS, False)
        self.auto_trigger_no_image = self.config.get_value(ConfigKeys.AUTO_TRIGGER_NO_IMAGE, True)
        self.enable_artist_metadata = self.config.get_value(ConfigKeys.ENABLE_ARTIST_METADATA, True)
        self.enable_album_metadata = self.config.get_value(ConfigKeys.ENABLE_ALBUM_METADATA, True)
        self.enable_track_metadata = self.config.get_value(ConfigKeys.ENABLE_TRACK_METADATA, True)
        self.enable_images = self.config.get_value(ConfigKeys.ENABLE_IMAGES, True)
        
        # 配置验证 + 初始化日志
        if not self.api_url:
            self.logger.error("[云音乐元数据 v1.6.1] API地址未配置，插件将无法正常工作")
        else:
            self.logger.info(
                "[云音乐元数据 v1.6.1] 初始化完成 - API地址: %s | 功能状态: 艺术家(%s) / 专辑(%s) / 歌曲(%s) / 图片(%s)",
                self.api_url,
                "启用" if self.enable_artist_metadata else "禁用",
                "启用" if self.enable_album_metadata else "禁用",
                "启用" if self.enable_track_metadata else "禁用",
                "启用" if self.enable_images else "禁用"
            )

    # ------------------------------
    # 艺术家元数据获取（日志增强）
    # ------------------------------
    async def get_artist_metadata(self, artist: Artist) -> Optional[MediaItemMetadata]:
        """获取艺术家元数据（日志增强）"""
        # 功能开关检查
        if not self.enable_artist_metadata:
            self.logger.debug("[云音乐元数据 v1.6.1] 艺术家元数据功能已禁用 - 跳过: %s", artist.name)
            return None
        
        # 清理艺术家名称
        original_artist_name = artist.name
        cleaned_artist_name = clean_artist_name(artist.name)
        if not cleaned_artist_name:
            self.logger.warning("[云音乐元数据 v1.6.1] 艺术家名称为空 - 跳过: %s", original_artist_name)
            return None
        
        # 记录名称清理日志（便于排查匹配问题）
        if cleaned_artist_name != original_artist_name:
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 清理艺术家名称 - 原名称: %s → 清理后: %s",
                original_artist_name, cleaned_artist_name
            )
        
        # 检查是否已有有效图片
        if self._has_valid_artist_images(artist):
            if not self.auto_trigger_no_image:
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 艺术家已有有效图片 - 跳过元数据获取: %s",
                    cleaned_artist_name
                )
                return None
            else:
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 艺术家已有图片，但启用了强制触发 - 继续获取: %s",
                    cleaned_artist_name
                )
        
        try:
            # 记录搜索请求
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 开始搜索艺术家 - 关键词: %s | 类型: 艺术家",
                cleaned_artist_name
            )
            
            # 获取数据
            data = await self._get_data(
                endpoint="search",
                keywords=cleaned_artist_name,
                type=100,
                limit=1
            )
            
            if not data:
                self.logger.warning("[云音乐元数据 v1.6.1] 未获取到艺术家数据 - 关键词: %s", cleaned_artist_name)
                return None
            
            if not data.get("result", {}).get("artists"):
                self.logger.warning(
                    "[云音乐元数据 v1.6.1] 搜索结果无匹配艺术家 - 关键词: %s | 原始响应: %s",
                    cleaned_artist_name, str(data)[:200]  # 截断响应避免日志过长
                )
                return None
            
            # 解析数据模型
            artist_data = CloudMusicArtist.from_dict(data["result"]["artists"][0])
            
            # 记录匹配结果
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 匹配到艺术家 - 云音乐ID: %d | 名称: %s | MBID: %s",
                artist_data.id,
                artist_data.name,
                artist_data.musicBrainzId or "无"
            )
            
            # 构建元数据
            metadata = self._build_artist_metadata(artist, artist_data)
            
            # 记录元数据更新日志（对应原始日志中的“updated 张碧晨”）
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 成功获取艺术家元数据 - 名称: %s | 图片: %s | MBID: %s",
                artist_data.name,
                "有" if (self.enable_images and artist_data.picUrl) else "无",
                artist_data.musicBrainzId or "无"
            )
            
            return metadata
            
        except Exception as e:
            self.logger.error(
                "[云音乐元数据 v1.6.1] 获取艺术家元数据失败 - 名称: %s | 错误: %s",
                cleaned_artist_name, str(e), exc_info=True  # 开启exc_info便于排查异常栈
            )
            return None

    # ------------------------------
    # 专辑元数据获取（日志增强）
    # ------------------------------
    async def get_album_metadata(self, album: Album) -> Optional[MediaItemMetadata]:
        """获取专辑元数据（日志增强）"""
        if not self.enable_album_metadata:
            self.logger.debug("[云音乐元数据 v1.6.1] 专辑元数据功能已禁用 - 跳过: %s", album.name)
            return None
        
        # 构建搜索关键词
        original_album_name = f"{album.name} {album.version}" if album.version else album.name
        cleaned_album_name = original_album_name.strip()
        artist_name = ""
        
        if album.artists:
            original_artist_name = album.artists[0].name
            artist_name = clean_artist_name(original_artist_name)
            # 记录艺术家名称清理日志
            if artist_name != original_artist_name:
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 清理专辑艺术家名称 - 原名称: %s → 清理后: %s",
                    original_artist_name, artist_name
                )
        
        # Various Artists特殊处理
        search_keyword = cleaned_album_name
        if artist_name.strip().lower() != "various artists" and artist_name:
            search_keyword = f"{cleaned_album_name} {artist_name}"
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 构建专辑搜索关键词 - 专辑: %s | 艺术家: %s → 关键词: %s",
                cleaned_album_name, artist_name, search_keyword
            )
        else:
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 构建专辑搜索关键词（Various Artists） - 专辑: %s → 关键词: %s",
                cleaned_album_name, search_keyword
            )
        
        if not search_keyword:
            self.logger.warning("[云音乐元数据 v1.6.1] 专辑搜索关键词为空 - 跳过: %s", original_album_name)
            return None
        
        try:
            # 构建搜索参数
            search_params = {
                "keywords": search_keyword,
                "type": 10,
                "limit": 3
            }
            
            # 添加MBID（如果有）
            mbid = album.get_external_id(ExternalID.MB_RELEASEGROUP)
            if mbid:
                search_params["mbid"] = mbid
                self.logger.debug("[云音乐元数据 v1.6.1] 专辑搜索附加MBID: %s", mbid)
            
            # 记录搜索请求
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 开始搜索专辑 - 关键词: %s | 类型: 专辑",
                search_keyword
            )
            
            # 获取数据
            data = await self._get_data(endpoint="search",** search_params)
            
            if not data:
                self.logger.warning("[云音乐元数据 v1.6.1] 未获取到专辑数据 - 关键词: %s", search_keyword)
                return None
            
            if not data.get("result", {}).get("albums"):
                self.logger.warning(
                    "[云音乐元数据 v1.6.1] 搜索结果无匹配专辑 - 关键词: %s | 原始响应: %s",
                    search_keyword, str(data)[:200]
                )
                return None
            
            # 解析数据模型
            album_data = CloudMusicAlbum.from_dict(data["result"]["albums"][0])
            
            # 记录匹配结果
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 匹配到专辑 - 云音乐ID: %d | 名称: %s | 发行时间: %s | MBID: %s",
                album_data.id,
                album_data.name,
                album_data.publishTime or "无",
                album_data.musicBrainzId or "无"
            )
            
            # 构建元数据
            metadata = self._build_album_metadata(album, album_data)
            
            # 记录元数据更新日志
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 成功获取专辑元数据 - 名称: %s | 图片: %s | 年份: %s",
                album_data.name,
                "有" if (self.enable_images and album_data.picUrl) else "无",
                parse_timestamp(album_data.publishTime) or "无"
            )
            
            # 批量写入标签（如果启用）
            if self.write_tags and hasattr(album, "tracks") and album.tracks:
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 开始批量写入专辑标签 - 专辑: %s | 曲目数: %d",
                    album.name, len(album.tracks)
                )
                asyncio.create_task(
                    self._batch_write_album_tags(album, album_data)
                )
            
            return metadata
            
        except Exception as e:
            self.logger.error(
                "[云音乐元数据 v1.6.1] 获取专辑元数据失败 - 专辑: %s | 错误: %s",
                search_keyword, str(e), exc_info=True
            )
            return None

    # ------------------------------
    # 歌曲元数据获取（日志增强）
    # ------------------------------
    async def get_track_metadata(self, track: Track) -> Optional[MediaItemMetadata]:
        """获取歌曲元数据（日志增强）"""
        if not self.enable_track_metadata:
            self.logger.debug("[云音乐元数据 v1.6.1] 歌曲元数据功能已禁用 - 跳过: %s", track.name)
            return None
        
        # 构建搜索关键词
        original_track_name = f"{track.name} {track.version}" if track.version else track.name
        cleaned_track_name = original_track_name.strip()
        artist_name = ""
        
        for track_artist in track.artists:
            original_artist_name = track_artist.name
            artist_name = clean_artist_name(original_artist_name)
            # 记录艺术家名称清理日志
            if artist_name != original_artist_name:
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 清理歌曲艺术家名称 - 原名称: %s → 清理后: %s",
                    original_artist_name, artist_name
                )
        
        search_keyword = f"{cleaned_track_name} {artist_name}".strip()
        self.logger.debug(
            "[云音乐元数据 v1.6.1] 构建歌曲搜索关键词 - 歌曲: %s | 艺术家: %s → 关键词: %s",
            cleaned_track_name, artist_name, search_keyword
        )
        
        if not search_keyword:
            self.logger.warning("[云音乐元数据 v1.6.1] 歌曲搜索关键词为空 - 跳过: %s", original_track_name)
            return None
        
        try:
            # 构建搜索参数
            search_params = {
                "keywords": search_keyword,
                "type": 1,
                "limit": 1
            }
            
            if track.mbid:
                search_params["mbid"] = track.mbid
                self.logger.debug("[云音乐元数据 v1.6.1] 歌曲搜索附加MBID: %s", track.mbid)
            
            # 记录搜索请求
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 开始搜索歌曲 - 关键词: %s | 类型: 歌曲",
                search_keyword
            )
            
            # 获取数据
            data = await self._get_data(endpoint="search", **search_params)
            
            # 数据不存在时的降级处理
            if not data or not data.get("result", {}).get("songs"):
                if not data:
                    self.logger.warning("[云音乐元数据 v1.6.1] 未获取到歌曲数据 - 关键词: %s", search_keyword)
                else:
                    self.logger.warning(
                        "[云音乐元数据 v1.6.1] 搜索结果无匹配歌曲 - 关键词: %s | 原始响应: %s",
                        search_keyword, str(data)[:200]
                    )
                
                # 降级写入基础标签
                if self.write_tags and hasattr(track, "file_path") and track.file_path and os.path.exists(track.file_path):
                    album_name = track.album.name if (hasattr(track, "album") and track.album) else ""
                    self.logger.debug(
                        "[云音乐元数据 v1.6.1] 降级写入歌曲基础标签 - 文件: %s | 艺术家: %s | 专辑: %s",
                        os.path.basename(track.file_path), artist_name, album_name
                    )
                    await self._write_basic_tags(track.file_path, artist_name, album_name, cleaned_track_name)
                return None
            
            # 解析数据模型
            track_data = CloudMusicTrack.from_dict(data["result"]["songs"][0])
            
            # 记录匹配结果
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 匹配到歌曲 - 云音乐ID: %d | 名称: %s | 专辑: %s",
                track_data.id,
                track_data.name,
                track_data.al.get("name", "无")
            )
            
            # 构建元数据
            metadata = self._build_track_metadata(track, track_data)
            
            # 记录元数据更新日志
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 成功获取歌曲元数据 - 名称: %s | 歌词: %s | 图片: %s",
                track_data.name,
                "有" if track_data.lyric else "无",
                "有" if (self.enable_images and track_data.al.get("picUrl")) else "无"
            )
            
            # 写入完整标签
            if self.write_tags and hasattr(track, "file_path") and track.file_path and os.path.exists(track.file_path):
                api_artist_name = track_data.ar[0].get("name", artist_name) if track_data.ar else artist_name
                cleaned_artist = clean_artist_name(api_artist_name)
                album_name = track_data.al.get("name", "")
                cover_url = track_data.al.get("picUrl", "")
                
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 开始写入歌曲完整标签 - 文件: %s | 艺术家: %s | 专辑: %s",
                    os.path.basename(track.file_path), cleaned_artist, album_name
                )
                await self._write_track_tags(
                    file_path=track.file_path,
                    artist_name=cleaned_artist,
                    album_name=album_name,
                    track_name=track_data.name,
                    cover_url=cover_url
                )
            
            return metadata
            
        except Exception as e:
            self.logger.error(
                "[云音乐元数据 v1.6.1] 获取歌曲元数据失败 - 歌曲: %s | 错误: %s",
                search_keyword, str(e), exc_info=True
            )
            return None

    # ------------------------------
    # 私有方法（日志增强）
    # ------------------------------
    def _has_valid_artist_images(self, artist: Artist) -> bool:
        """检查艺术家是否有有效图片（日志增强）"""
        if not self.enable_images:
            return False
        
        if not hasattr(artist, 'images') or not artist.images:
            self.logger.debug("[云音乐元数据 v1.6.1] 艺术家无图片数据 - 名称: %s", artist.name)
            return False
        
        valid_images = [img for img in artist.images if img.path and img.type == ImageType.THUMB]
        if len(valid_images) == 0:
            self.logger.debug("[云音乐元数据 v1.6.1] 艺术家图片无效（无有效路径） - 名称: %s", artist.name)
        else:
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 艺术家有有效图片 - 数量: %d | 名称: %s",
                len(valid_images), artist.name
            )
        return len(valid_images) > 0

    @use_cache(CACHE_TTL, persistent=True)
    @throttle_with_retries
    async def _get_data(self, endpoint: str, **kwargs: Any) -> Optional[Dict[str, Any]]:
        """获取API数据（日志增强版）"""
        if not self.api_url:
            self.logger.error("[云音乐元数据 v1.6.1] API地址未配置，无法发起请求")
            return None
        
        url = f"{self.api_url}/{endpoint}"
        self.logger.debug(
            "[云音乐元数据 v1.6.1] 发起API请求 - URL: %s | 参数: %s",
            url, str(kwargs)
        )
        
        try:
            async with self.mass.http_session.get(
                url, 
                params=kwargs, 
                ssl=False, 
                timeout=aiohttp.ClientTimeout(total=5)
            ) as response:
                # 记录响应状态
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] API响应状态 - URL: %s | 状态码: %d",
                    url, response.status
                )
                
                # 处理限流
                if response.status == 429:
                    backoff_time = int(response.headers.get("Retry-After", 5))
                    self.logger.warning(
                        "[云音乐元数据 v1.6.1] API限流 - URL: %s | 重试等待: %ds",
                        url, backoff_time
                    )
                    raise ResourceTemporarilyUnavailable("API限流", backoff_time=backoff_time)
                
                # 处理临时错误
                if response.status in (502, 503):
                    self.logger.warning(
                        "[云音乐元数据 v1.6.1] API服务器临时不可用 - URL: %s | 状态码: %d",
                        url, response.status
                    )
                    raise ResourceTemporarilyUnavailable("服务器临时不可用", backoff_time=10)
                
                # 处理客户端错误
                if response.status in (400, 401, 404):
                    self.logger.warning(
                        "[云音乐元数据 v1.6.1] API请求失败（客户端错误） - URL: %s | 状态码: %d",
                        url, response.status
                    )
                    return None
                
                response.raise_for_status()
                result = cast(Dict[str, Any], await response.json(loads=json_loads))
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] API请求成功 - URL: %s | 响应长度: %d字符",
                    url, len(str(result))
                )
                return result
                
        except ResourceTemporarilyUnavailable as e:
            # 由throttle_with_retries处理重试，记录重试日志
            self.logger.warning(
                "[云音乐元数据 v1.6.1] API请求重试 - URL: %s | 原因: %s | 等待: %ds",
                url, e.args[0], e.backoff_time
            )
            raise
        except (
            aiohttp.client_exceptions.ContentTypeError,
            JSONDecodeError,
            aiohttp.client_exceptions.ClientConnectorError,
            aiohttp.client_exceptions.ServerDisconnectedError,
            TimeoutError,
        ) as e:
            self.logger.error(
                "[云音乐元数据 v1.6.1] API请求异常 - URL: %s | 类型: %s | 错误: %s",
                url, type(e).__name__, str(e)
            )
            return None
        except Exception as e:
            self.logger.error(
                "[云音乐元数据 v1.6.1] API请求未知错误 - URL: %s | 错误: %s",
                url, str(e), exc_info=True
            )
            return None

    def _build_artist_metadata(self, artist: Artist, artist_data: CloudMusicArtist) -> MediaItemMetadata:
        """构建艺术家元数据（日志增强）"""
        metadata = MediaItemMetadata()
        
        # 基础元数据
        metadata.genres = {artist_data.genre} if artist_data.genre else set()
        metadata.description = artist_data.briefDesc or artist_data.desc or ""
        
        # 图片
        if self.enable_images and artist_data.picUrl:
            metadata.images = UniqueList()
            metadata.images.append(
                MediaItemImage(
                    type=ImageType.THUMB,
                    path=artist_data.picUrl,
                    provider=self.instance_id,
                    remotely_accessible=True,
                )
            )
        
        # 更新MBID（对应原始日志中的“Unable to get musicbrainz ID”）
        if artist_data.musicBrainzId:
            if not artist.mbid and artist.provider == "library":
                if isinstance(artist, ItemMapping):
                    artist = self.mass.music.artists.artist_from_item_mapping(artist)
                
                artist.mbid = artist_data.musicBrainzId
                asyncio.create_task(self.mass.music.artists.update_item_in_library(artist.item_id, artist))
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 更新艺术家MBID - 名称: %s | MBID: %s",
                    artist.name, artist_data.musicBrainzId
                )
            else:
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 艺术家已有MBID - 名称: %s | 现有MBID: %s | 新MBID: %s",
                    artist.name, artist.mbid or "无", artist_data.musicBrainzId
                )
        else:
            self.logger.warning(
                "[云音乐元数据 v1.6.1] 未获取到艺术家MBID - 名称: %s（对应原始日志的“Unable to get musicbrainz ID”）",
                artist.name
            )
        
        return metadata

    def _build_album_metadata(self, album: Album, album_data: CloudMusicAlbum) -> MediaItemMetadata:
        """构建专辑元数据（日志增强）"""
        metadata = MediaItemMetadata()
        
        # 基础元数据
        metadata.genres = {album_data.genre} if album_data.genre else set()
        metadata.description = album_data.description or ""
        
        # 图片
        if self.enable_images and album_data.picUrl:
            metadata.images = UniqueList()
            metadata.images.append(
                MediaItemImage(
                    type=ImageType.THUMB,
                    path=album_data.picUrl,
                    provider=self.instance_id,
                    remotely_accessible=True,
                )
            )
        
        # 年份
        year = parse_timestamp(album_data.publishTime)
        if not album.year and year:
            album.year = year
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 更新专辑年份 - 名称: %s | 原年份: %s | 新年份: %d",
                album.name, album.year or "无", year
            )
        
        # 更新MBID
        if album_data.musicBrainzId:
            if not album.get_external_id(ExternalID.MB_RELEASEGROUP) and album.provider == "library":
                album.add_external_id(ExternalID.MB_RELEASEGROUP, album_data.musicBrainzId)
                asyncio.create_task(self.mass.music.albums.update_item_in_library(album.item_id, album))
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 更新专辑MBID - 名称: %s | MBID: %s",
                    album.name, album_data.musicBrainzId
                )
        else:
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 未获取到专辑MBID - 名称: %s",
                album.name
            )
        
        return metadata

    def _build_track_metadata(self, track: Track, track_data: CloudMusicTrack) -> MediaItemMetadata:
        """构建歌曲元数据（日志增强）"""
        metadata = MediaItemMetadata()
        
        # 基础元数据
        metadata.lyrics = track_data.lyric or ""
        metadata.genres = {track_data.genre} if track_data.genre else set()
        metadata.description = track_data.description or ""
        
        # 图片
        if self.enable_images and (pic_url := track_data.al.get("picUrl")):
            metadata.images = UniqueList()
            metadata.images.append(
                MediaItemImage(
                    type=ImageType.THUMB,
                    path=pic_url,
                    provider=self.instance_id,
                    remotely_accessible=True,
                )
            )
        
        # 更新艺术家MBID
        artist_mbid = track_data.ar[0].get("musicBrainzId") if track_data.ar else None
        if artist_mbid:
            for track_artist in track.artists:
                if not track_artist.mbid and track_artist.provider == "library":
                    if isinstance(track_artist, ItemMapping):
                        track_artist = self.mass.music.artists.artist_from_item_mapping(track_artist)
                    
                    track_artist.mbid = artist_mbid
                    asyncio.create_task(self.mass.music.artists.update_item_in_library(track_artist.item_id, track_artist))
                    self.logger.debug(
                        "[云音乐元数据 v1.6.1] 更新歌曲艺术家MBID - 艺术家: %s | MBID: %s",
                        track_artist.name, artist_mbid
                    )
        else:
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 未获取到歌曲艺术家MBID - 歌曲: %s",
                track.name
            )
        
        return metadata

    async def _batch_write_album_tags(self, album: Album, album_data: CloudMusicAlbum):
        """批量写入专辑标签（日志增强）"""
        if not album.tracks:
            self.logger.debug("[云音乐元数据 v1.6.1] 专辑无曲目，跳过批量标签写入 - 专辑: %s", album.name)
            return
        
        cover_url = album_data.picUrl or ""
        artist_name = clean_artist_name(album.artists[0].name) if album.artists else ""
        album_name = album_data.name or album.name
        
        # 构建任务列表
        tasks = []
        for idx, track in enumerate(album.tracks, 1):
            if hasattr(track, "file_path") and track.file_path and os.path.exists(track.file_path):
                track_name = track.name or ""
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 加入专辑标签写入队列 - 专辑: %s | 曲目%d: %s | 文件: %s",
                    album.name, idx, track_name, os.path.basename(track.file_path)
                )
                tasks.append(
                    self._write_track_tags(
                        file_path=track.file_path,
                        artist_name=artist_name,
                        album_name=album_name,
                        track_name=track_name,
                        cover_url=cover_url
                    )
                )
        
        # 执行任务
        if tasks:
            self.logger.debug(
                "[云音乐元数据 v1.6.1] 开始执行专辑标签写入 - 专辑: %s | 任务数: %d",
                album.name, len(tasks)
            )
            results = await asyncio.gather(*tasks, return_exceptions=True)
            error_count = sum(1 for r in results if isinstance(r, Exception))
            
            if error_count > 0:
                self.logger.warning(
                    "[云音乐元数据 v1.6.1] 专辑标签写入失败 %d/%d - 专辑: %s | 失败详情: %s",
                    error_count, len(tasks), album.name,
                    [str(r) for r in results if isinstance(r, Exception)]
                )
            else:
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 专辑标签写入完成 - 专辑: %s | 成功数: %d",
                    album.name, len(tasks)
                )

    async def _write_basic_tags(self, file_path: str, artist_name: str, album_name: str, track_name: str):
        """写入基础标签（日志增强）"""
        file_basename = os.path.basename(file_path)
        self.logger.debug(
            "[云音乐元数据 v1.6.1] 写入基础标签 - 文件: %s | 艺术家: %s | 专辑: %s | 歌曲: %s",
            file_basename, artist_name, album_name, track_name
        )
        
        try:
            if file_path.lower().endswith(".mp3"):
                audio = MP3(file_path, ID3=ID3)
                with suppress(error):
                    audio.add_tags()
                
                if artist_name:
                    audio.tags.add(TPE1(encoding=3, text=artist_name))
                    audio.tags.add(TPE2(encoding=3, text=artist_name))
                if album_name:
                    audio.tags.add(TALB(encoding=3, text=album_name))
                if track_name:
                    audio.tags.add(TIT2(encoding=3, text=track_name))
                
                audio.save()
                self.logger.debug("[云音乐元数据 v1.6.1] 基础标签写入成功 - 文件: %s", file_basename)
            
            elif file_path.lower().endswith(".flac"):
                audio = FLAC(file_path)
                
                if artist_name:
                    audio["artist"] = artist_name
                    audio["albumartist"] = artist_name
                if album_name:
                    audio["album"] = album_name
                if track_name:
                    audio["title"] = track_name
                
                audio.save()
                self.logger.debug("[云音乐元数据 v1.6.1] 基础标签写入成功 - 文件: %s", file_basename)
                
        except Exception as e:
            self.logger.error(
                "[云音乐元数据 v1.6.1] 写入基础标签失败 - 文件: %s | 错误: %s",
                file_basename, str(e), exc_info=True
            )

    async def _write_track_tags(self, file_path: str, artist_name: str, album_name: str, track_name: str, cover_url: str = ""):
        """写入完整标签（含封面）（日志增强）"""
        file_basename = os.path.basename(file_path)
        self.logger.debug(
            "[云音乐元数据 v1.6.1] 写入完整标签 - 文件: %s | 艺术家: %s | 专辑: %s | 封面: %s",
            file_basename, artist_name, album_name, "有" if cover_url else "无"
        )
        
        try:
            if file_path.lower().endswith(".mp3"):
                audio = MP3(file_path, ID3=ID3)
                with suppress(error):
                    audio.add_tags()
                
                # 基础标签
                if artist_name:
                    audio.tags.add(TPE1(encoding=3, text=artist_name))
                    audio.tags.add(TPE2(encoding=3, text=artist_name))
                if album_name:
                    audio.tags.add(TALB(encoding=3, text=album_name))
                if track_name:
                    audio.tags.add(TIT2(encoding=3, text=track_name))
                
                # 封面
                cover_success = False
                if cover_url:
                    try:
                        async with self.mass.http_session.get(cover_url, timeout=3) as resp:
                            cover_data = await resp.read()
                            audio.tags.add(APIC(
                                encoding=3,
                                mime="image/jpeg",
                                type=3,
                                desc="Cover",
                                data=cover_data
                            ))
                        cover_success = True
                    except Exception as e:
                        self.logger.warning(
                            "[云音乐元数据 v1.6.1] 封面下载失败 - 文件: %s | 封面URL: %s | 错误: %s",
                            file_basename, cover_url, str(e)
                        )
                
                audio.save()
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 完整标签写入成功 - 文件: %s | 封面: %s",
                    file_basename, "成功" if cover_success else "失败"
                )
            
            elif file_path.lower().endswith(".flac"):
                audio = FLAC(file_path)
                
                # 基础标签
                if artist_name:
                    audio["artist"] = artist_name
                    audio["albumartist"] = artist_name
                if album_name:
                    audio["album"] = album_name
                if track_name:
                    audio["title"] = track_name
                
                # 封面
                cover_success = False
                if cover_url:
                    try:
                        async with self.mass.http_session.get(cover_url, timeout=3) as resp:
                            cover_data = await resp.read()
                            audio.clear_pictures()
                            pic = Picture()
                            pic.data = cover_data
                            pic.mime = "image/jpeg"
                            pic.type = 3
                            audio.add_picture(pic)
                        cover_success = True
                    except Exception as e:
                        self.logger.warning(
                            "[云音乐元数据 v1.6.1] 封面下载失败 - 文件: %s | 封面URL: %s | 错误: %s",
                            file_basename, cover_url, str(e)
                        )
                
                audio.save()
                self.logger.debug(
                    "[云音乐元数据 v1.6.1] 完整标签写入成功 - 文件: %s | 封面: %s",
                    file_basename, "成功" if cover_success else "失败"
                )
                
        except Exception as e:
            self.logger.error(
                "[云音乐元数据 v1.6.1] 写入完整标签失败 - 文件: %s | 错误: %s",
                file_basename, str(e), exc_info=True
            )

# ------------------------------
# 插件初始化函数（保持兼容）
# ------------------------------
async def setup(
    mass: MusicAssistant, manifest: ProviderManifest, config: ProviderConfig
) -> ProviderInstanceType:
    """初始化插件实例"""
    return CloudMusicMetadataProvider(mass, manifest, config, SUPPORTED_FEATURES)

async def get_config_entries(
    mass: MusicAssistant,
    instance_id: Optional[str] = None,
    action: Optional[str] = None,
    values: Optional[Dict[str, ConfigValueType]] = None,
) -> tuple[ConfigEntry, ...]:
    """返回配置项"""
    return (
        ConfigEntry(
            key=ConfigKeys.ENABLE_ARTIST_METADATA,
            type=ConfigEntryType.BOOLEAN,
            label="启用艺术家元数据获取",
            default_value=True,
            required=False,
        ),
        ConfigEntry(
            key=ConfigKeys.ENABLE_ALBUM_METADATA,
            type=ConfigEntryType.BOOLEAN,
            label="启用专辑元数据获取",
            default_value=True,
            required=False,
        ),
        ConfigEntry(
            key=ConfigKeys.ENABLE_TRACK_METADATA,
            type=ConfigEntryType.BOOLEAN,
            label="启用歌曲元数据获取",
            default_value=True,
            required=False,
        ),
        ConfigEntry(
            key=ConfigKeys.ENABLE_IMAGES,
            type=ConfigEntryType.BOOLEAN,
            label="启用图片获取",
            default_value=True,
            required=False,
        ),
        ConfigEntry(
            key=ConfigKeys.WRITE_TAGS,
            type=ConfigEntryType.BOOLEAN,
            label="写入元数据到本地文件标签（测试版）",
            default_value=False,
            description="自动补充缺失的ID3标签并写入本地音乐文件",
            required=False,
        ),
        ConfigEntry(
            key=ConfigKeys.AUTO_TRIGGER_NO_IMAGE,
            type=ConfigEntryType.BOOLEAN,
            label="无图片时自动触发获取",
            default_value=True,
            description="当艺术家无图片时自动触发云音乐API请求",
            required=False,
        ),
        ConfigEntry(
            key=ConfigKeys.API_URL,
            type=ConfigEntryType.STRING,
            label="自建云音乐API地址",
            description="你的自建云音乐API服务地址",
            required=True,
            default_value="http://localhost:3003",
        ),
    )